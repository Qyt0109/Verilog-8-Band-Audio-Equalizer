Assume that a and b are two numbers in Qn1.m1 and Qn2.m2 formats, respectively.
The product a x b will be in Qn.m format where n=n1+n2 and m=m1+m2.
This product wordlength, i.e. n+m, is long enough to avoid any potential overflow.
To find a x b, we can ignore the binary point of a and b, perform the multiplication,
and, then, put the binary point to the left of the m th bit of the product to obtain the correct multiplication result.

##### coeffs:
- signed fixed-point 16.16
- [-0.5, 0.5 - 1.52587890625e-05]

##### input/output wav audio sample:
- signed integer 16
- [-32768, 32768 - 1]

##### internal computing register:
- rounding: floor
- overflow: saturate
- ###### product:
  - signed fixed-point 32.18
  - [-8192.0, 8192.0 - 3.814697265625e-06]
  - TEST: max value of coeffs mul max value of sample
    ```
    sign with unsigned:
    = -0.125 x 32767                                                                        Dec with sign
    = .uu_(1)000_0000_0000_0000 x (0)111_1111_1111_1111.                                    Bin with sign bit and frac dot
    = 1000_0000_0000_0000 x 0111_1111_1111_1111                                             Bin
    = 1111_1111_1111_1111_1000_0000_0000_0000 x 0000_0000_0000_0000_0111_1111_1111_1111     Bin sign extended
    = ...0111_1111_1111_1110__1100_0000_0000_0000_1000_0000_0000_0000                       Bin sign extended
    = 1100_0000_0000_0000_1000_0000_0000_0000                                               Bin
    = (1)100_0000_0000_00.00_1000_0000_0000_0000                                            Bin with sign bit and frac dot
    = -4095.875                                                                             Dec with sign

    => TEST OK

    sign with sign:
    = -0.125 x -32768                                                                       Dec with sign
    = .uu_(1)000_0000_0000_0000 x (1)000_0000_0000_0000.                                    Bin with sign and frac dot
    = 1000_0000_0000_0000 x 1000_0000_0000_0000                                             Bin
    = 1111_1111_1111_1111_1000_0000_0000_0000 x 1111_1111_1111_1111_1000_0000_0000_0000     Bin sign extended
    = ...0_1111_1111_1111_1111_0000_0000_0000_0000__0100_0000_0000_0000_0000_0000_0000_0000 Bin sign extended
    = 0100_0000_0000_0000_0000_0000_0000_0000                                               Bin
    = (0)100_0000_0000_00.00_0000_0000_0000_0000                                            Bin with sign bit and frac dot
    = 4096                                                                                  Dec with sign

    => TEST OK

    all one case:
    -1 x -3.814697265625e-06
    = (1)111_1111_1111_1111. x .uu_(1)111_1111_1111_1111
    = 1111_1111_1111_1111 x 1111_1111_1111_1111
    = 11111111111111111111111111111111 x 11111111111111111111111111111111
    = 1111_1111_1111111000000000_0000_0001 = -0.4999961853027344
    ```

quantizied coeffs:
-0.000156402587890625                     
-0.000476837158203125                     
-0.00080108642578125                      
-0.001102447509765625                     
-0.00131988525390625                      
-0.001361846923828125                     
-0.0011138916015625                       
-0.000476837158203125                     
0.000579833984375                        
0.001995086669921875                     
0.0035858154296875                       
0.005039215087890625                     
0.005970001220703125                     
0.00595855712890625                      
0.00466156005859375                      
0.0019073486328125                       
-0.002216339111328125                     
-0.00730133056640625                      
-0.01262664794921875                      
-0.01718902587890625                      
-0.019847869873046875                     
-0.019458770751953125                     
-0.0150909423828125                       
-0.006183624267578125                     
0.007282257080078125                     
0.024730682373046875                     
0.04499053955078125                      
0.0663909912109375                       
0.08695220947265625                      
0.104633331298828125                     
0.1175994873046875                       
0.124454498291015625                     
0.124454498291015625                     
0.1175994873046875                       
0.104633331298828125                     
0.08695220947265625                      
0.0663909912109375                       
0.04499053955078125                      
0.024730682373046875                     
0.007282257080078125                     
-0.006183624267578125                     
-0.0150909423828125                       
-0.019458770751953125                     
-0.019847869873046875                     
-0.01718902587890625                      
-0.01262664794921875                      
-0.00730133056640625                      
-0.002216339111328125                     
0.0019073486328125                       
0.00466156005859375                      
0.00595855712890625                      
0.005970001220703125                     
0.005039215087890625                     
0.0035858154296875                       
0.001995086669921875                     
0.000579833984375                        
-0.000476837158203125                     
-0.0011138916015625                       
-0.001361846923828125                     
-0.00131988525390625                      
-0.001102447509765625                     
-0.00080108642578125                      
-0.000476837158203125                     
-0.000156402587890625                     


largest product
0.124454498291015625 * 32767
~ 4078

need
ceil(log2(4078))
= 12 bit

largest accumlator
4078 * 63
= 256914

need
ceil(log2(256914))
= 18 bit

coeffs
16 01 15

input
16 01 15

output
16 00 31

product
31 00 31

accum
33 02 31




coeffs
16 00 18

input
16 16 00

output
16 16 00

product
00 15 18

accum
00 00 00